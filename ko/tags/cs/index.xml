<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>CS on What is This&#39; BLOG</title>
        <link>https://whatisthis8047.github.io/ko/tags/cs/</link>
        <description>Recent content in CS on What is This&#39; BLOG</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ko-KR</language>
        <lastBuildDate>Fri, 08 Mar 2024 11:13:28 +0900</lastBuildDate><atom:link href="https://whatisthis8047.github.io/ko/tags/cs/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>[LeetCode] 51. N-Queens (1)</title>
        <link>https://whatisthis8047.github.io/ko/post/leetcode_51/</link>
        <pubDate>Fri, 08 Mar 2024 11:13:28 +0900</pubDate>
        
        <guid>https://whatisthis8047.github.io/ko/post/leetcode_51/</guid>
        <description>&lt;h1 id=&#34;n퀸-문제와-역추적backtracking-알고리즘&#34;&gt;N퀸 문제와 역추적(Backtracking) 알고리즘&lt;/h1&gt;
&lt;h2 id=&#34;문제-소개&#34;&gt;문제 소개&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;리트코드 원본 문제 : &lt;a class=&#34;link&#34; href=&#34;https://leetcode.com/problems/n-queens/description/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;(리트코드 사이트)&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.&lt;br&gt;
Given an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.&lt;br&gt;
Each solution contains a distinct board configuration of the n-queens&amp;rsquo; placement, where &amp;lsquo;Q&amp;rsquo; and &amp;lsquo;.&amp;rsquo; both indicate a queen and an empty space, respectively.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;한국어로 번역해보자면,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;n-퀸 퍼즐은 여왕들이 서로 공격하지 않도록 n x n 짜리 체스판에 n개의 여왕을 배치하는 문제이다.
정수 n이 주어졌을 때, 가능한 모든 해를 반환하며 해답의 순서는 상관 없다.
각 해는 n개의 여왕을 배치할 수 있는 보드의 구성을 포함해야 하며 &amp;lsquo;Q&amp;rsquo;는 여왕, &amp;lsquo;.&amp;lsquo;는 빈칸을 나타낸다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 문제는 제시문 자체를 이해하는 것이 어렵기 때문에 설명을 조금 덧붙이자면, 입력값은 단순하게 n = 3 이나, n = 4 등 간단한 정수를 입력으로 받게 되고, 우리는 이 n에 따른 n x n 짜리 체스판이 있다고 가정하는 겁니다. 그 체스판 안에 n개의 퀸의 경로가 겹치지 않도록 배치도를 반환하는 문제인 것이죠. 문제 설명에 제시된 예시를 한번 보자면,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;입력값: &lt;code&gt;n = 4  &lt;/code&gt;
출력값: &lt;code&gt;[[&amp;quot;.Q..&amp;quot;,&amp;quot;...Q&amp;quot;,&amp;quot;Q...&amp;quot;,&amp;quot;..Q.&amp;quot;],[&amp;quot;..Q.&amp;quot;,&amp;quot;Q...&amp;quot;,&amp;quot;...Q&amp;quot;,&amp;quot;.Q..&amp;quot;]]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;아래는 입력값 &lt;code&gt;n = 4&lt;/code&gt; 일 때 출력값을 시각화 하여 보여준 그림입니다. 즉, 출력의 각 원소는 하나의 n x n 짜리 체스판을 나타내고, 체스판 내의 각 원소는 위에서부터 가로로 (또는 세로로도 읽을 수 있습니다) &lt;strong&gt;한 줄&lt;/strong&gt;씩 나타낸 값이 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://whatisthis8047.github.io/queens.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;queens&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;n = 4&lt;/code&gt; 일 경우에는 위의 두가지 답 외에는 퀸을 놓을 수 있는 방법이 없습니다. 이런 문제를 어떻게 하면 풀 수 있을까요?&lt;/p&gt;
&lt;h2 id=&#34;접근법&#34;&gt;접근법&lt;/h2&gt;
&lt;h3 id=&#34;역추적-알고리즘&#34;&gt;역추적 알고리즘&lt;/h3&gt;
&lt;p&gt;오늘 이 문제와 연관된 키워드는 &lt;strong&gt;역추적(Backtracking) 알고리즘&lt;/strong&gt; 입니다. 그렇다면 역추적 알고리즘이 무엇인지 위키에서 살펴봅시다. 위키는 Backtracking을 &amp;lsquo;퇴각검색&amp;rsquo;으로 번역합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;퇴각검색(영어: backtracking, 한국어: 백트래킹)은 한정 조건을 가진 문제를 풀려는 전략이다. 문제가 한정 조건을 가진 경우 원소의 순서는 해결 방법과 무관하다. 이런 문제는 변수 집합으로 이뤄지는데, 한정 조건을 구성하려면 각각의 변수들은 값이 있어야 한다. &lt;strong&gt;퇴각검색은 모든 조합을 시도해서 문제의 해를 찾는다. 이것이 장점이 될 수 있는 이유는 퇴각검색 구현 방법들이 많은 부분 조합들을 배제하기 때문이다.&lt;/strong&gt; 결국 풀이 시간이 단축된다. (출처: &lt;a class=&#34;link&#34; href=&#34;https://ko.wikipedia.org/wiki/%ED%87%B4%EA%B0%81%EA%B2%80%EC%83%89&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;위키피디아&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;설명이 너무 어려운 것 같네요ㅠ. 일단 지금 중요한 부분만 뽑아 굵은 글씨로 표시해두었습니다. 말 그대로 주어진 모든 조합을 시도해서 해를 찾는데, 이를 구현하는 방법에서 부분 조합들을 베제하기 때문에 풀이가 빨라진다~ 로 읽으면 되겠습니다. 반복을 줄이는 방법에도 여러가지 유형이 있지만, 거기까진 다루지 않겠습니다.&lt;/p&gt;
&lt;p&gt;이를 구현하는 아주 기본적인 프레임을 의사코드로 확인해보죠:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py3&#34; data-lang=&#34;py3&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;backtrack&lt;/span&gt;(경로, 선택 리스트): &lt;span style=&#34;color:#75715e&#34;&gt;# 경로와 선택 리스트는 둘 다 리스트 변수입니다.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; 종료 조건 만족시:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        result&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add(경로)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; 선택 &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; 선택 리스트: &lt;span style=&#34;color:#75715e&#34;&gt;#핵심부분&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        선택하기 &lt;span style=&#34;color:#75715e&#34;&gt;# 선택 리스트 중 지금 선택한 경우 제거 후 경로 리스트에 추가&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        backtrack(경로, 선택 리스트)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        선택 해제 &lt;span style=&#34;color:#75715e&#34;&gt;# 경로 리스트에서 아까 선택한 경우를 제거 후 선택 리스트에 추가&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;위 코드를 머리속에서 잠깐 굴려봅시다. 먼저 backtrack이라는 함수가 재귀적으로 실행되면서 선택 리스트에 있는 원소를 하나씩 경로 리스트로 옮깁니다. 더 이상 재귀적으로 실행될 선택 리스트 원소가 없다면, (명시되어있진 않았습니다) 다시 선택을 해제하며 기존 불렀던 backtrack 함수가 실행될 겁니다. 결국 선택 리스트에 있는 모든 원소를 처음부터 끝까지 경로 리스트로 옮겼다 돌아오게 될겁니다.&lt;/p&gt;
&lt;h3 id=&#34;알고리즘을-적용한-문제풀이&#34;&gt;알고리즘을 적용한 문제풀이&lt;/h3&gt;
&lt;p&gt;다시 문제로 돌아옵시다. 결국 우리는 이번 N-Queens 문제를 역추적 알고리즘을 이용하여 푸는 것이 핵심입니다. 머리를 조금 아프겠지만 위의 프레임을 문제에 적용해봅시다.&lt;/p&gt;
&lt;p&gt;일단 backtrack을 적용하기에 앞서, n x n 체스판을 구성해야합니다. 일단 주어진 체스판이 비었다고 생각하고 만들면 &amp;ldquo;.&amp;ldquo;이 n개씩 들어간 줄이 n개 나열되면 되겠네요.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py3&#34; data-lang=&#34;py3&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;board &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;n &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(n)]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;이렇게 만들면 &lt;code&gt;n = 4&lt;/code&gt; 일 때 &lt;code&gt;[&amp;quot;....&amp;quot;,&amp;quot;....&amp;quot;,&amp;quot;....&amp;quot;,&amp;quot;....&amp;quot;]&lt;/code&gt;이 되겠네요. 빈 체스판을 완성했습니다! 다음은 backtrack 알고리즘입니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py3&#34; data-lang=&#34;py3&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;backtrack&lt;/span&gt;(board, row): &lt;span style=&#34;color:#75715e&#34;&gt;# 경로, 선택리스트가 각각 board와 row로 변환&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; row &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; len(board): &lt;span style=&#34;color:#75715e&#34;&gt;# 지금 확인하는 row가 마지막 행을 넘으면 종료&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        res&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(board[:]) &lt;span style=&#34;color:#75715e&#34;&gt;# 지금 결과값 board를 결과 리스트에 저장&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; col &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(len(board)):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; isValid(board, row, col) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        board[row] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; board[row][:col] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Q&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; board[row][&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;col:]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        backtrack(board, row &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        board[row] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; board[row][:col] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; board[row][&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;col:]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;if row == len(board): # 지금 확인하는 row가 마지막 행을 넘으면 종료함.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py3&#34; data-lang=&#34;py3&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Solution&lt;/span&gt;(object):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;solveNQueens&lt;/span&gt;(self, n):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        board &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;n &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(n)]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;backtrack&lt;/span&gt;(board, row):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;nonlocal&lt;/span&gt; res
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; row &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; len(board):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                res&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(board[:])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; col &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(len(board)):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; isValid(board, row, col) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                board[row] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; board[row][:col] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Q&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; board[row][&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;col:]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                backtrack(board, row &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                board[row] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; board[row][:col] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; board[row][&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;col:]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;isValid&lt;/span&gt;(board, row, col):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(row):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; board[i][col] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Q&amp;#34;&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i, j &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; zip(range(row &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;), range(col &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, len(board), &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; board[i][j] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Q&amp;#34;&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i, j &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; zip(range(row &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;), range(col &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; board[i][j] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Q&amp;#34;&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        backtrack(board, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;해당 PS 풀이는 도서 &lt;!-- raw HTML omitted --&gt;&lt;a class=&#34;link&#34; href=&#34;https://product.kyobobook.co.kr/detail/S000061898577&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;[코딩 인터뷰를 위한 알고리즘 치트시트, 푸둥라이 지음]&lt;/a&gt;&lt;!-- raw HTML omitted --&gt;을 참고하며 진행중임을 밝힙니다.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>[LeetCode] 300. Longest Increasing Subsequence</title>
        <link>https://whatisthis8047.github.io/ko/post/leetcode_300/</link>
        <pubDate>Mon, 04 Mar 2024 11:47:26 +0900</pubDate>
        
        <guid>https://whatisthis8047.github.io/ko/post/leetcode_300/</guid>
        <description>&lt;h1 id=&#34;longest-increasing-subsequence-최장-증가-부분수열-문제로-동적계획법-이해하기&#34;&gt;Longest Increasing Subsequence (최장 증가 부분수열) 문제로 동적계획법 이해하기&lt;/h1&gt;
&lt;h2 id=&#34;문제-소개&#34;&gt;문제 소개&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;리트코드 원본 문제 : &lt;a class=&#34;link&#34; href=&#34;https://leetcode.com/problems/longest-increasing-subsequence/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;(리트코드 사이트)&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;이번 문제는 설명이 비교적 간단합니다! &lt;em&gt;(물론 설명만&amp;hellip;? 간단합니다.)&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Given an integer array nums, return the length of &lt;strong&gt;the longest strictly increasing subsequence&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;한국어로 번역해보자면,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;nums라는 정수로 된 어레이를 입력받을 때, &lt;strong&gt;최장 (강한)증가 부분수열&lt;/strong&gt;의 길이를 반환하여라.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(strictly increasing 즉, 강한 증가라는 뜻은 이전 값보다 크거나 &lt;strong&gt;같을&lt;/strong&gt; 때가 아니라 오로지 &lt;strong&gt;클 경우&lt;/strong&gt;에만 증가로 인정한다는 의미입니다.)&lt;/p&gt;
&lt;h3 id=&#34;subsequence란&#34;&gt;Subsequence란?&lt;/h3&gt;
&lt;p&gt;여기서 subsequence (&amp;lsquo;부분수열&amp;rsquo;로 번역했지만 원소가 굳이 &amp;lsquo;수&amp;rsquo;일 필요는 없습니다!)라는 용어가 헷갈릴 수 있는 부분이 있어 짚고 넘어가겠습니다. 먼저 부분수열 보다 큰 개념인 수열(sequence)를 정의하면 &amp;lsquo;순서가 있는 원소들로 구성된 리스트&amp;rsquo;로 정의할 수 있습니다. 부분수열은 어떤 수열의 &lt;strong&gt;순서를 바꾸지 않으면서&lt;/strong&gt; 원소를 삭제하여 얻을 수 있는 수열입니다.&lt;/p&gt;
&lt;p&gt;예시를 들어보자면, letter = [A, B, C, D, E] 라는 수열이 있다면, subsequence는 [A, D], [B, C, E], [E],&amp;hellip; 등등 될 수 있는 것이죠. 전부 표현하지는 않았지만 그 개념은 충분히 이해하셨을 겁니다.&lt;/p&gt;
&lt;h2 id=&#34;접근법&#34;&gt;접근법&lt;/h2&gt;
&lt;p&gt;자 문제로 다시 돌아오면, 우리가 구해야하는 출력값은 최장 (강한)증가 부분수열입니다. 문제에서 주어진 조건은 &amp;lsquo;최장&amp;rsquo;과 &amp;lsquo;(강한)증가&amp;rsquo;로 나눌 수 있겠군요. 예시를 보며 풀이를 한번 짐작해 봅시다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;예시 1번&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Input: &lt;code&gt;nums = [10,9,2,5,3,7,101,18]&lt;/code&gt;&lt;br&gt;
Output: &lt;code&gt;4&lt;/code&gt;&lt;br&gt;
이유: 최장 증가 부분수열이 되는 경우는 &lt;code&gt;[2,3,7,101]&lt;/code&gt; 또는 &lt;code&gt;[2,3,7,18]&lt;/code&gt;이 되는군요. 그러므로 &lt;strong&gt;출력값은 4&lt;/strong&gt;가 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;예시 2번&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Input: &lt;code&gt;nums = [0,1,0,3,2,3]&lt;/code&gt;&lt;br&gt;
Output: &lt;code&gt;4&lt;/code&gt;&lt;br&gt;
이유: 최장 증가 부분수열은 &lt;code&gt;[0,1,2,3]&lt;/code&gt;으로 출력값은 4가 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;예시 3번&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Input: &lt;code&gt;nums = [7,7,7,7,7,7,7]&lt;/code&gt;&lt;br&gt;
Output: &lt;code&gt;1&lt;/code&gt;&lt;br&gt;
이유: 강한 증가 부분수열이기 때문에 &lt;code&gt;[7]&lt;/code&gt;이 최장의 부분수열이 되며 출력값은 1입니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;풀이를 동적 계획법의 관점에서 생각해봅시다. 우리는 이 문제를 더 &lt;strong&gt;잘게 쪼개서&lt;/strong&gt; 해결하고 싶습니다. 그런 방법이야 무수히 많겠지만, 먼저 떠올릴 수 있는 방법은 &lt;strong&gt;정수 어레이를 앞에서부터 차례로 지나가며 가장 긴 부분수열의 길이를 반환&lt;/strong&gt;하도록 하는 것입니다!&lt;/p&gt;
&lt;p&gt;간단하게 예를 들어보면서 풀이를 생각해봅시다. &lt;code&gt;nums = [1, 4, 3, 4, 2]&lt;/code&gt; 라는 어레이를 입력값으로 받았을 때, 우리가 원하는 풀이 방식은 다음과 같을겁니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;먼저 첫번째 값인 1을 지나면서 최장 부분수열은 &lt;code&gt;[1]&lt;/code&gt;이니 길이가 1입니다.&lt;/li&gt;
&lt;li&gt;다음으로는 4를 지나면서 &lt;code&gt;[1, 4]&lt;/code&gt;가 지금 최장이니까 길이는 2가 되겠네요,&lt;/li&gt;
&lt;li&gt;다음은 3을 지나는데, 여기선 &lt;code&gt;[1, 3]&lt;/code&gt;과 &lt;code&gt;[1, 4]&lt;/code&gt;가 최장 부분수열이 될테니 길이는 2입니다.&lt;/li&gt;
&lt;li&gt;다음은 4죠. &lt;code&gt;[1, 3, 4]&lt;/code&gt;이 가능하니 최장 부분수열의 길이는 3이네요.&lt;/li&gt;
&lt;li&gt;마지막으로 2를 지날 땐 &lt;code&gt;[1, 3, 4]&lt;/code&gt;가 여전히 최장 부분수열입니다. 길이는 3이 되겠네요.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;그렇다면 이런 결과값을 저장할 수 있는 배열이 하나 더 있으면 좋겠다는 생각이 듭니다! 주어진 &lt;code&gt;nums&lt;/code&gt;의 원소들을 거치면서 각 원소일 때의 최장 부분수열의 길이를 저장해둔다면 그 뒤에는 저장해 둔 배열 안에서 최댓값만 찾으면 되니까요. 우리는 그런 배열의 이름을 &lt;code&gt;dp[]&lt;/code&gt;라고 합시다. 그럼 아래와 같은 배열 두개가 생기는겁니다. (index는 보면서 이해하기 편할 것 같아 추가했습니다)&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;index&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;0&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;2&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;3&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;4&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;nums&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;dp&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;다시 말하자면, &lt;code&gt;dp[i]&lt;/code&gt;값은 각 &lt;code&gt;nums[i]&lt;/code&gt;값 에서의 최장 부분수열의 길이입니다.&lt;/p&gt;
&lt;p&gt;그럼 가장 중요한 일이 남았습니다. &lt;strong&gt;&amp;ldquo;그래서 이 &lt;code&gt;dp[]&lt;/code&gt;는 어떻게 구현하는데?&amp;rdquo;&lt;/strong&gt; 음&amp;hellip; 알고리즘을 푸는 감이 있는 분이시라면 위의 힌트만으로도 충분히 구현해보실 수 있겠지만, 다행히도(?) 저는 아니었기 때문에 꼬박 반나절을 끙끙 앓다가 결국 풀이를 보고 따라갔습니다. (그래도 오래 고민한 만큼 풀이를 빠르게 이해할 수는 있었네요ㅎㅎ)&lt;/p&gt;
&lt;p&gt;지금은 이 포스트에서 동적 계획법을 배운다는 전제하에 접근하고 있기 때문에 곧바로 이를 이용한 풀이로 넘어가겠습니다. 먼저 동적 계획법으로 문제 풀이를 계획할 때, 중요한 키 포인트는 두가지입니다. 하나는 &lt;strong&gt;초기조건&lt;/strong&gt;, 다른 하나는 &lt;strong&gt;상태 전이 알고리즘&lt;/strong&gt; 입니다. (책에서는 상태 전이 방정식으로 소개되었지만 너무 수학적인 표현 같아 알고리즘이라는 용어로 바꾸었습니다)&lt;/p&gt;
&lt;p&gt;먼저, &lt;strong&gt;초기 조건&lt;/strong&gt;은 말 그대로 가장 처음 반복문이나, 재귀문이 &lt;strong&gt;시작할 때의 상태&lt;/strong&gt;를 의미합니다. 다음으로, &lt;strong&gt;상태 전이 알고리즘&lt;/strong&gt;은 쉽게 말해 반복문이나 재귀적으로 함수가 실행될 때 &lt;strong&gt;각 단계에서 뭘 반복하는가?&lt;/strong&gt; 입니다. 생소한 이름이어서 어렵게 다가올 수는 있지만 겁먹지 않으셔도 됩니다! 여기서 반복하는 기능이야 함수에 따라 천차만별이 될 수 있습니다. 예를 들어, 이진 탐색의 경우엔 (주어진 배열에서 목표 숫자를 찾을 때 까지)배열을 절반으로 나누는 것이 그 기능이 되겠네요.&lt;/p&gt;
&lt;h3 id=&#34;초기-조건&#34;&gt;초기 조건&lt;/h3&gt;
&lt;p&gt;자, 그럼 정의를 알았으니 초기조건과 상태 전이 알고리즘을 끌어내 봅시다. 초기 조건은 &lt;code&gt;dp[i]&lt;/code&gt;의 &lt;code&gt;i=1&lt;/code&gt; 일 때, 즉 &lt;code&gt;dp[1]&lt;/code&gt;일 때의 값을 찾는 겁니다. 이를 해석하면 &lt;code&gt;nums&lt;/code&gt;의 첫번째 값인 &lt;code&gt;nums[1]&lt;/code&gt;을 지날 때의 최장 부분수열을 묻는 것과 같으니, 너무나도 당연하게 1입니다. 파이썬으로 정의해봅시다!&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py3&#34; data-lang=&#34;py3&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;dp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; _ &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(len(nums))]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;이렇게 dp를 정의하면 nums의 길이와 같은 리스트에 각 원소가 1로 초기화하게 됩니다. 즉, &lt;code&gt;dp = [1, 1, 1, ...]&lt;/code&gt; 와 같아지죠. 여기서 사용한 &lt;code&gt;[for ~ in]&lt;/code&gt; 으로 리스트를 선언하는 문법은 &lt;em&gt;list comprehension&lt;/em&gt; 이라는 기법입니다. 이런 간단한 배열을 만들때 유용한 기법이니 관심있으신 분은 구글에서 한번 읽어 보시는 걸 추천합니다. (이해가 안가신다면 반복문을 밖으로 빼어 다른 방법으로 정의하셔도 무관합니다)&lt;/p&gt;
&lt;h3 id=&#34;상태-전이-알고리즘&#34;&gt;상태 전이 알고리즘&lt;/h3&gt;
&lt;p&gt;그럼 상태 전이 알고리즘은 어떻게 될까요? 이를 생각해보기 쉽도록 위의 예시인 &lt;code&gt;nums = [1, 4, 3, 4, 2]&lt;/code&gt;를 한번 더 끌어옵시다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;index&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;0&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;2&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;3&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;4&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;nums&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;dp&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;우리가 i가 2에서 3로 넘어갈 때, 즉 &lt;code&gt;nums[2]&lt;/code&gt;에서 &lt;code&gt;nums[3]&lt;/code&gt;로 넘어가면서 최장 부분수열의 길이인 &lt;code&gt;dp[3]&lt;/code&gt;을 어떻게 수정했을까요? 그 과정을 파헤치면 알고리즘이 나옵니다! 우린 인덱스를 넘어가면서 의식적으로 내가 이전에 있던 최장 부분수열을 생각합니다. 즉, &lt;code&gt;i=2&lt;/code&gt; 에서 &lt;code&gt;dp[2]&lt;/code&gt;를 만든 &lt;code&gt;[1,4]&lt;/code&gt;와 &lt;code&gt;[1,3]&lt;/code&gt;을 생각했다가, &lt;code&gt;i=3&lt;/code&gt;으로 넘어갈 때 &lt;code&gt;nums[3] = 4&lt;/code&gt;가 기존의 두 최장 부분수열에서 더 이어질 수 있는가를 판단하죠. 이 경우엔 &lt;code&gt;[1, 4]&lt;/code&gt; 뒤에는 올 수 없지만, &lt;code&gt;[1, 3]&lt;/code&gt; 뒤에는 올 수 있으므로, &lt;code&gt;dp[3]&lt;/code&gt;값은 &lt;code&gt;[1, 3, 4]&lt;/code&gt;의 길이인 &lt;code&gt;3&lt;/code&gt;이 되었습니다. 여기서 핵심이 되는 과정은 &lt;strong&gt;앞에서 4보다 작은 수로 끝나는 부분순열을 찾아 이어붙이면 된다&lt;/strong&gt;는 것이었습니다. 즉, 우리의 상태 전이 알고리즘은 현재 &lt;code&gt;num[i]&lt;/code&gt; 값을 보고 그보다 작은 값들로 끝나는 부분수열의 길이 &lt;code&gt;dp[j]&lt;/code&gt;에 이어주기만 하면 됩니다.&lt;/p&gt;
&lt;p&gt;글로만 읽게 되니 아직 불분명하게 느껴질 수 있을겁니다.&lt;br&gt;
파이썬 코드로 확인해봅시다. (책에는 C++ 코드로 나와있지만 이해하기 쉽도록 파이썬으로 변형했습니다)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py3&#34; data-lang=&#34;py3&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(len(nums)): &lt;span style=&#34;color:#75715e&#34;&gt;# 들어오는 nums 값의 인덱스를 i로 설정하고 반복문 돌리기&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(i): &lt;span style=&#34;color:#75715e&#34;&gt;# j는 현재 인덱스 i 이전의 값들을 훑기 위해 설정&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; nums[i] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; nums[j]: &lt;span style=&#34;color:#75715e&#34;&gt;# 만약 현재 nums[i] 값 보다 작은 nums[j]가 있다면 아래 실행&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            dp[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(dp[i], dp[j] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;# 지금까지 나온 dp[i]값과 dp[j]+1 값을 비교해서 더 큰 쪽을 dp[i] 값으로 업데이트&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;# 여기서 dp[j]+1 인 이유는 기존의 최장 부분순열의 길이에 지금 값 nums[i]를 붙이므로 값이 하나 커지는 것을 의미!&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;코드에 대한 설명은 주석으로 하나씩 설명해두었습니다.&lt;/p&gt;
&lt;p&gt;우리는 동적 계획법에서 가장 중요한 &lt;strong&gt;1. 초기조건&lt;/strong&gt;과 &lt;strong&gt;2. 상태 전이 알고리즘&lt;/strong&gt; 두가지를 모두 작성했습니다! 이제 이걸 합쳐주기만 하면 우리가 원하는 결과가 나옵니다! 아래는 완성된 코드입니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py3&#34; data-lang=&#34;py3&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Solution&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;lengthOfLIS&lt;/span&gt;(self, nums: List[int]) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; int:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        dp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; _ &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(len(nums))] &lt;span style=&#34;color:#75715e&#34;&gt;# dp를 nums 길이와 같고 각 원소가 1인 리스트로 초기화 (초기조건)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(len(nums)): &lt;span style=&#34;color:#75715e&#34;&gt;# 아까 상태전이 알고리즘을 그대로 사용&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(i):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; nums[i] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; nums[j]:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    dp[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(dp[i], dp[j]&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; max(dp) &lt;span style=&#34;color:#75715e&#34;&gt;# dp 리스트에서 최댓값 반환&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;그럼 이번에도 리트코드 문제 동적 계획법으로 뽀개기 성공입니다! 지금까지 따라오신 분들에게 박수를 드려요 👏👏👏!!!&lt;/p&gt;
&lt;p&gt;문제를 풀어 기쁘시겠지만! 잠깐! 이 해법은 과연 효율적인 풀이였을까요? 해당 풀이는 반복문을 두번 겹쳐 사용했기 때문에 시간 복잡도는 $O(n^2)$ 될껍니다. 풀이는 명쾌했는데 복잡도는 썩 좋아보이지 않죠? 사실 이 문제는 더 &lt;em&gt;&lt;strong&gt;효율적인&lt;/strong&gt;&lt;/em&gt; 알고리즘이 존재합니다. 하지만 떠올리기 너무너무 어렵기에 이번 포스트는 여기서 멈추고! 다음 포스트에 따로 다루도록 하겠습니다.&lt;/p&gt;
&lt;p&gt;다시, 이 문제를 통해 가져가야할 핵심 아이디어는 &lt;strong&gt;&lt;em&gt;초기조건&lt;/em&gt;과 &lt;em&gt;상태전이 알고리즘&lt;/em&gt;을 어떻게 세울까?&lt;/strong&gt; 고민하는 부분입니다. 팁을 드리자면, 데이터에 어떤 값을 저장하게 하는게 좋을지 고민하는 것이 도움이 됩니다. 이번 문제에 dp 배열이 각 nums 위치에서 최장 부분수열의 길이였던 것 처럼요. 저도 다른 문제를 풀이할 때 떠올릴 수 있도록 기억해두도록 하겠습니다.&lt;/p&gt;
&lt;p&gt;그럼 다들 좋은 하루 보내시길!&lt;/p&gt;
</description>
        </item>
        <item>
        <title>[LeetCode] 322. Coin Change</title>
        <link>https://whatisthis8047.github.io/ko/post/leetcode_322/</link>
        <pubDate>Thu, 25 Jan 2024 21:15:26 +0900</pubDate>
        
        <guid>https://whatisthis8047.github.io/ko/post/leetcode_322/</guid>
        <description>&lt;h1 id=&#34;coin-change-동전-계산하기-문제로-동적-계획법-이해하기&#34;&gt;Coin Change (동전 계산하기) 문제로 동적 계획법 이해하기&lt;/h1&gt;
&lt;h2 id=&#34;문제-소개&#34;&gt;문제 소개&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;리트코드 원본 문제  : &lt;a class=&#34;link&#34; href=&#34;https://leetcode.com/problems/coin-change/description/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;(리트코드 사이트)&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.&lt;br&gt;
Return &lt;strong&gt;the fewest number of coins&lt;/strong&gt; that you need to make up that amount. If that amount of money &lt;strong&gt;cannot&lt;/strong&gt; be made up by any combination of the coins, &lt;strong&gt;return -1&lt;/strong&gt;. You may assume that you have an infinite number of each kind of coin.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이를 한국어로 해석해보자면,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;입력으로 &amp;ldquo;단위가 다른 동전 종류(어레이)&amp;ldquo;와 &amp;ldquo;동전들을 가지고 만들 총 금액&amp;rdquo; 두가지를 받습니다.
이때, 총 금액 값을 만드는 &lt;strong&gt;가장 적은 동전의 갯수를 반환&lt;/strong&gt;하십시오. 만약 가지고 있는 동전들로 총 금액을 만들 수 없는 경우에는 -1을 반환하며, 각 동전의 개수는 항상 총액을 만들 수 있을 만큼 충분히 많다고 가정합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 문제는 책 초반에 다양한 PS 문제들의 기본적인 접근법이 되는 프레임들을 안내해주는 1.2장에서 소개 되었습니다. 저는 아직 알고리즘 문제를 풀어보는 경험이 아에 없다시피 하기 때문에 쉽게 설명하고 넘어가는 부분에도 오랜시간을 보내며 어떻게 작동하는지 그려보며 따라가 보았습니다!&lt;/p&gt;
&lt;p&gt;책에서 제시하는 키워드는 &lt;strong&gt;DP, 동적 계획법&lt;/strong&gt;으로의 접근입니다.&lt;/p&gt;
&lt;h2 id=&#34;접근법&#34;&gt;접근법&lt;/h2&gt;
&lt;h3 id=&#34;동적-계획법-dynamic-programming&#34;&gt;동적 계획법 [Dynamic Programming]&lt;/h3&gt;
&lt;p&gt;동적 계획법의 개념 자체는 &lt;strong&gt;어렵고 복잡한 문제를 간단한 여러개의 작은 문제들로 나누어 풀이해내는 방법&lt;/strong&gt;입니다. 분명 개념은 아주 쉽죠..? 하지만 알고리즘 문제를 풀면서 동적 계획법을 써보세요~ 하면 어디서부터 시작할지 막막할겁니다.&lt;/p&gt;
&lt;p&gt;일단 너무 간단한 개념 설명을 조금 보충할 필요가 있을 것 같아서 위키 설명을 참조해 보겠습니다!&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;(동적 계획법이란) 주어진 문제를 풀기 위해서, 문제를 여러 개의 하위 문제(subproblem)로 나누어 푼 다음, 그것을 결합하여 최종적인 목적에 도달하는 것이다. 각 하위 문제의 해결을 계산한 뒤, 그 해결책을 저장하여 후에 같은 하위 문제가 나왔을 경우 그것을 간단하게 해결할 수 있다. 이러한 방법으로 동적 계획법은 계산 횟수를 줄일 수 있다. 특히 이 방법은 하위 문제의 수가 기하급수적으로 증가할 때 유용하다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;그러니까 지금 문제를 하위 문제들로 나누고, 저장해서 큰 문제로 어떻게 접근해낼지 고민하는 것이 필요한거네요. 다시 동전 계산하기 문제를 봅시다. 지금 주어진 큰 문제는 뭘까요? 가진 동전들로 총 금액을 만드는 것이겠죠? 이를 조금 무식하게 접근하면, 총 금액에서 가지고 있는 종류의 동전을 하나씩 빼보면서 정확히 0을 맞추어 낼 수 있는지를 확인하면 되겠네요. 그런 모든 경우에서 가장 적은 동전이 나오는 걸 반환하면 정답이 되겠죠? 그렇다면 여기서 &lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&amp;lsquo;작은 문제&amp;rsquo;는 &amp;lsquo;총 금액에서 종류별 금액을 빼보기&amp;rsquo;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;가 되겠습니다.
그럼 총 금액을 인자로 받아 가지고 있는 동전의 종류마다 하나씩 빼는 함수를 짜봅시다!&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py3&#34; data-lang=&#34;py3&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dp&lt;/span&gt;(n):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;여기 하위 문제를 푸는 함수 dp(n)을 만들었습니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;남은 금액 n을 인자로 받고, 가지고 있는 종류의 동전(coin)마다 하나씩 뺀 뒤에 재귀적으로 다시 dp(n - coin)을 넣습니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; coin &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; coins:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; min(res, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; dp(n &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; coin))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;위 함수는 동전을 뺐을 때 금액이 0이 되는 경우나 음수가 되는 예외적인 경우를 아직 포함하지 않았네요.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py3&#34; data-lang=&#34;py3&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; min(result, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; dp(n &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; coin))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;위 코드가 오늘 동적 계획법 적용의 핵심입니다. 재귀적으로 &lt;code&gt;dp(n - coin)&lt;/code&gt;을 부름으로써 coin을 빼는 &lt;strong&gt;모든 경우를 계산&lt;/strong&gt;합니다. 그 뒤엔 이를 각각 지금의 result값과 비교해서 더 적은 값(최소 값)을 돌려주도록 동작합니다. (저는 이 짧은 부분이 어떻게 움직이는지 이해하는 데에만 한참이 걸린 것 같네요.)&lt;/p&gt;
&lt;p&gt;이제 해당 문제를 실제로 풀이하기 위해 코드를 수정해봅시다. Solution 클래스와 coinChange 함수는 LeetCode에서 제공하는 기본 템플릿이며, 문제를 풀기 위해서는 이 내부에 입력값과 출력값을 고려하여 코드를 작성하면 됩니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py3&#34; data-lang=&#34;py3&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Solution&lt;/span&gt;(object):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;coinChange&lt;/span&gt;(self, coins, amount):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        :type coins: List[int]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        :type amount: int
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        :rtype: int
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dp&lt;/span&gt;(n): 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;# 초기조건(base case)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;# 최솟값을 구할 때 비교하기 위해 가장 큰 값인 양의 무한대로 초기화&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; float(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;INF&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; coin &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; coins:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                subproblem &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dp(n &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; coin)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;# 하위 문제의 답이 없을 시 -1을 리턴하므로 건너뛰기&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; subproblem &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; min(result, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; subproblem)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; result &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; float(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;INF&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; dp(amount)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;문제 해결을 위해서 몇가지를 수정하긴 했지만, 핵심 구조는 동일합니다!&lt;br&gt;
개인적으로 바로 이해가 어려웠던 부분은 &lt;code&gt;result = float(&#39;INF&#39;)&lt;/code&gt; 부분이었습니다. 함수의 핵심 구조는 &lt;code&gt;result = min(result, 1 + dp(n - coin))&lt;/code&gt; 이고 여기서 &lt;code&gt;min()&lt;/code&gt;을 이용하여 최솟값을 &lt;strong&gt;누적 비교&lt;/strong&gt;하여 구하고 있습니다. 이렇게 되면 처음 초기화 한 result의 값이 &lt;code&gt;min()&lt;/code&gt;에 들어갔을 때 나올 수 있는 최솟값 보다 항상 커야만 하며, 그러므로 정의할 수 있는 가장 큰 값인 양의 무한대로 초기화를 해야 어떠한 예외없이 result의 초기값이 항상 크다는걸 보장할 수 있게 됩니다. (주어진 값은 항상 양의 무한대보단 작을 테니까요)&lt;/p&gt;
&lt;h3 id=&#34;동적-계획법-개선하기&#34;&gt;동적 계획법 개선하기&lt;/h3&gt;
&lt;p&gt;위의 방식은 단순 재귀함수를 이용한 접근으로 동적계획법을 잘 이용하긴 했지만 &lt;strong&gt;같은 계산을 중복으로 하게 되는 문제&lt;/strong&gt;가 있습니다. 위키피디아의 인용문에서 &amp;ldquo;각 하위 문제의 해결을 계산한 뒤, 그 해결책을 저장하여 후에 같은 하위 문제가 나왔을 경우 그것을 간단하게 해결할 수 있다&amp;rdquo; 고 서술되어 있듯이, 우리는 이미
예를 들어 &lt;code&gt;coins = [2,3,5], amount = 17&lt;/code&gt; 이 입력되었을 때, 위 함수는 &lt;code&gt;17 - 5 - 5 - 2 - 5 = 0&lt;/code&gt; 와&lt;code&gt;17 - 5 - 2 - 5 - 5 = 0&lt;/code&gt;를 계산하는 경우애 첫 &lt;code&gt;dp(17 - 5)&lt;/code&gt; 값을 매번 일일히 계산하고 나서야 값을 반환합니다.
하지만 만약 이 &lt;code&gt;dp(12)&lt;/code&gt; 값을 어딘가 저장해두고 다시 찾을 때 반환한다면 중복 없이 훨씬 빠르게 문제를 끝낼 수 있게 될겁니다! 이처럼 저장해두는 장소를 보통 &lt;strong&gt;메모&lt;/strong&gt;라고 선언 한다. 아래는 메모를 이용한 동적 계획법 풀이를 적어보았습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py3&#34; data-lang=&#34;py3&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Solution&lt;/span&gt;(object):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;coinChange&lt;/span&gt;(self, coins, amount):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        :type coins: List[int]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        :type amount: int
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        :rtype: int
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        memo &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dp&lt;/span&gt;(n):  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; memo: &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; memo[n] &lt;span style=&#34;color:#75715e&#34;&gt;# 메모에 값이 있으면 바로 반환&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; float(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;INF&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; coin &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; coins:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                sub &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dp(n &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; coin)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sub &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; min(result, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; sub)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            memo[n] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; result &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; result &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; float(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;INF&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; memo[n]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; dp(amount)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;memo&lt;/code&gt;라는 변수를 딕셔너리 형태로 선언하고 계산하기 전에 저장된 메모 값을 먼저 확인하여 중복된 계산을 바로 피할 수 있게 되었습니다!&lt;/p&gt;
&lt;p&gt;해당 PS 풀이는 도서 &lt;!-- raw HTML omitted --&gt;&lt;a class=&#34;link&#34; href=&#34;https://product.kyobobook.co.kr/detail/S000061898577&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;[코딩 인터뷰를 위한 알고리즘 치트시트, 푸둥라이 지음]&lt;/a&gt;&lt;!-- raw HTML omitted --&gt;을 참고하며 진행중임을 밝힙니다.&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
